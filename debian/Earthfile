VERSION --use-cache-command 0.6

ARG OS_VERSION="11"
FROM debian:${OS_VERSION}-slim

# VsCode will respect the default shell as configured inside the container
# see: https://github.com/microsoft/vscode-remote-release/issues/350
ENV SHELL="/bin/bash"

builder:
  COPY ./scripts/. /usr/local/bin/.
  RUN for file in /usr/local/bin/*.bash; do mv "$file" "${file%%.bash}"; done
  RUN chmod +x /usr/local/bin/*
  ENV DEBIAN_FRONTEND="noninteractive"
  RUN apt-get -y update
  DO +FROM_NOW --NAME="ca-certificates"
  RUN apt-get -y install --no-install-recommends ca-certificates
  RUN sed -i 's/http:\/\//https:\/\//g' /etc/apt/sources.list
  DO +TO_NOW --NAME="ca-certificates"

# Simply touches a new marker file so we can refer
# to it's timestamp in the "TO_NOW" script.
FROM_NOW:
  COMMAND
  ARG NAME="default"
  RUN from-now ${NAME}

# Uses a "tar" pipe to gather up all the changed files between the "FROM_NOW"
# marker and "NOW", excluding things like log files, package manager cache &
# other temporary files.
#
# Usage might look like this:
#
#   foo-provider:
#     FROM big-builder-image
#     DO +FROM_NOW "foo-install"
#     RUN install foo commands
#     DO +TO_NOW "foo-install"
#     SAVE ARTIFACT /tmp/changed-foo-install/*
#
#   foo-consumer:
#     FROM small-runtime-image
#     COPY +foo-provider/ /
#
# Of course if you know exactly what you built you don't need any of this
# and can define an approriate "SAVE ARTIFACT" command instead. This is most
# useful for collecting changes made by package managers where you do not have
# direct control over what was installed & where it was installed.
TO_NOW:
  COMMAND
  ARG NAME="default"
  RUN to-now ${NAME}

# Install the ./hook scripts into the image. All lifecycle hooks
# apart from "initializeCommand" run inside the container.
#
# see: https://code.visualstudio.com/docs/remote/devcontainerjson-reference#_lifecycle-scripts
INSTALL_HOOKS:
  COMMAND
  COPY ./hooks/. /usr/local/bin/.
  RUN for file in /usr/local/bin/*.bash; do mv "$file" "${file%%.bash}"; done
  RUN chmod +x /usr/local/bin/*

# Create our entrypoint that will execute each time the devcontainer is started.
#
# This is designed to work with: "overrideCommand": false
# If this property in the devcontainer.json config is set to true (the default)
# then the entrypoint will not be executed.
#
# NOTE: The entrypoint will execute with root permissions so it can do things
# like setup permissions to the mounted docker socket & then it will use gosu
# to switch to the unprivilaged user.
#
# see: https://code.visualstudio.com/docs/remote/containers-advanced#_adding-startup-commands-to-the-docker-image-instead
#INSTALL_ENTRYPOINT:
#  COMMAND
#  ARG USERNAME="code"
#  ARG USER_UID="1000"
#  ARG USER_GID="${USER_UID}"
#  ARG DOCKER_SOURCE_SOCKET="/var/run/docker-host.sock"
#  ARG DOCKER_TARGET_SOCKET="/var/run/docker.sock"
#  ARG ENTRYPOINT_LOGS="/tmp/entrypoint-logs"
#  RUN install-entrypoint
#  ENTRYPOINT [ "/entrypoint.bash" ]
#  CMD [ "sleep", "infinity" ]
